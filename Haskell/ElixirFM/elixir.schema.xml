<?xml version="1.0" encoding="utf-8"?>
<pml_schema version="1.1" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/">
    <revision>1.0.0</revision>
    <description>ElixirFM Lexicon</description>

    <root name="ElixirFM" type="Lexicon.type" />

    <type name="Lexicon.type">
        <structure>
            <member name="meta">
                <structure>
                    <member name="revision">
                        <cdata format="any"/>
                    </member>
                    <member name="date">
                        <cdata format="any"/>
                    </member>
                </structure>
            </member>
            <member name="data" required="1">
                <sequence role="#TREES">
                    <element name="Wrap" type="Wrap.type"/>
                </sequence>
            </member>
        </structure>
    </type>

    <type name="Wrap.type">
        <container role="#NODE">
            <sequence role="#CHILDNODES">
                <element name="NestS" type="Nest.type"/>
                <element name="NestT" type="Nest.type"/>
                <element name="NestQ" type="Nest.type"/>
                <element name="NestL" type="Nest.type"/>
            </sequence>
        </container>
    </type>

    <type name="Nest.type">
        <structure role="#NODE">
            <member name="root" type="Root.type"/>
            <member name="ents" role="#CHILDNODES">
                <sequence>
                    <element name="Entry" type="Entry.type"/>
                </sequence>
            </member>
        </structure>
    </type>

    <type name="Entry.type">
        <structure role="#NODE">
            <member name="morphs" type="Morphs.type" required="1"/>
            <member name="entity" type="Entity.type" required="1"/>
            <member name="limits" type="Limits.type"/>
            <member name="reflex" type="Reflex.type"/>
            <member name="vallex" type="Vallex.type" role="#CHILDNODES"/>
        </structure>
    </type>

    <type name="Root.type">
        <cdata format="any"/>
    </type>

    <type name="Entity.type">
        <sequence content_pattern="(Verb|Noun|Adj|Pron|Num|Adv|Prep|Conj|Part|Intj|Xtra|Ynit|Zero|Grph)">
            <element name="Verb">
                <structure>
                    <member name="form" required="1">
                        <list type="Form.type" ordered="1"/>
                    </member>
                    <member name="pfirst">
                        <list type="Pattern.type" ordered="1"/>
                    </member>
                    <member name="imperf">
                        <list type="Pattern.type" ordered="1"/>
                    </member>
                    <member name="second">
                        <list type="Pattern.type" ordered="1"/>
                    </member>
                    <member name="tense" type="Tense.type"/>
                    <member name="voice" type="Voice.type"/>
                </structure>
            </element>
            <element name="Noun">
                <structure>
                    <member name="plural" type="Plural.type"/>
                    <member name="gender" type="Gender.type"/>
                    <member name="number" type="Number.type"/>
                    <member name="derive" type="Derive.type"/>
                </structure>
            </element>
            <element name="Adj" >
                <structure>
                    <member name="plural" type="Plural.type"/>
                    <member name="femini" type="Femini.type"/>
                    <member name="number" type="Number.type"/>
                </structure>
            </element>
            <element name="Pron">
                <container/>
            </element>
            <element name="Num">
                <structure>
                    <member name="plural" type="Plural.type"/>
                    <member name="femini" type="Femini.type"/>
                </structure>
            </element>
            <element name="Adv">
                <container/>
            </element>
            <element name="Prep">
                <container/>
            </element>
            <element name="Conj">
                <container/>
            </element>
            <element name="Part">
                <container/>
            </element>
            <element name="Intj">
                <container/>
            </element>
            <element name="Xtra">
                <container/>
            </element>
            <element name="Ynit">
                <container/>
            </element>
            <element name="Zero">
                <container/>
            </element>
            <element name="Grph">
                <container/>
            </element>
        </sequence>
    </type>

    <type name="Form.type">
        <choice>
            <value>I</value>
            <value>II</value>
            <value>III</value>
            <value>IV</value>
            <value>V</value>
            <value>VI</value>
            <value>VII</value>
            <value>VIII</value>
            <value>IX</value>
            <value>X</value>
            <value>XI</value>
            <value>XII</value>
            <value>XIII</value>
            <value>XIV</value>
            <value>XV</value>
        </choice>
    </type>

    <type name="Tense.type">
        <choice>
            <value>Perfect</value>
            <value>Imperfect</value>
            <value>Imperative</value>
        </choice>
    </type>

    <type name="Voice.type">
        <choice>
            <value>Active</value>
            <value>Passive</value>
        </choice>
    </type>

    <type name="Plural.type">
        <list type="Morphs.type" ordered="1"/>
    </type>

    <type name="Femini.type">
        <list type="Morphs.type" ordered="1"/>
    </type>

    <type name="Gender.type">
        <choice>
            <value>Masculine</value>
            <value>Feminine</value>
        </choice>
    </type>

    <type name="Number.type">
        <choice>
            <value>Singular</value>
            <value>Dual</value>
            <value>Plural</value>
        </choice>
    </type>

    <type name="Derive.type">
        <choice>
            <value>------F---</value>
        </choice>
    </type>

    <type name="Morphs.type">
        <cdata format="any"/>
    </type>

    <type name="Pattern.type">
        <cdata format="any"/>
    </type>

    <type name="Reflex.type">
        <list ordered="1">
            <cdata format="any"/>
        </list>
    </type>

    <type name="Limits.type">
        <structure>
            <member name="fst" type="Tags.type"/>
            <member name="snd">
                <list ordered="1">
                    <structure>
                        <member name="fst">
                            <list type="Tags.type" ordered="1"/>
                        </member>
                        <member name="snd">
                            <list type="Morphs.type" ordered="1"/>
                        </member>
                    </structure>
                </list>
            </member>
        </structure>
    </type>

    <type name="Tags.type">
        <cdata format="any"/>
    </type>

    <type name="Vallex.type">
        <sequence>
            <element name="Frame">
                <structure role="#NODE">
                    <member name="reflex" type="Reflex.type"/>
                    <member name="slots" role="#CHILDNODES">
                        <sequence>
                            <element name="Slot" type="Slot.type"/>
                        </sequence>
                    </member>
                    <member name="links">
                        <list ordered="1">
                            <cdata format="any"/>
                        </list>
                    </member>
                </structure>
            </element>
        </sequence>
    </type>

    <type name="Slot.type">
        <structure role="#NODE">
            <member name="name" type="Functor.type"/>
            <member name="type" type="Type.type"/>
            <member name="data" role="#CHILDNODES">
                <sequence>
                    <element name="Node" type="Node.type"/>
                </sequence>
            </member>
        </structure>
    </type>

    <type name="Node.type">
        <structure role="#NODE">
            <member name="form">
                <cdata format="any"/>
            </member>
            <member name="tag" type="Tags.type"/>
            <member name="with" role="#CHILDNODES">
                <sequence>
                    <element name="Node" type="Node.type"/>
                </sequence>
            </member>
        </structure>
    </type>

    <type name="Functor.type">
        <choice>
            <value>ACT</value>
            <value>PAT</value>
            <value>ADDR</value>
            <value>EFF</value>
            <value>ORIG</value>
            <value>ACMP</value>
            <value>ADVS</value>
            <value>AIM</value>
            <value>APP</value>
            <value>APPS</value>
            <value>ATT</value>
            <value>BEN</value>
            <value>CAUS</value>
            <value>CNCS</value>
            <value>COMPL</value>
            <value>COND</value>
            <value>CONJ</value>
            <value>CONFR</value>
            <value>CPR</value>
            <value>CRIT</value>
            <value>CSQ</value>
            <value>CTERF</value>
            <value>DENOM</value>
            <value>DES</value>
            <value>DIFF</value>
            <value>DIR1</value>
            <value>DIR2</value>
            <value>DIR3</value>
            <value>DISJ</value>
            <value>DPHR</value>
            <value>ETHD</value>
            <value>EXT</value>
            <value>EV</value>
            <value>FPHR</value>
            <value>GRAD</value>
            <value>HER</value>
            <value>ID</value>
            <value>INTF</value>
            <value>INTT</value>
            <value>LOC</value>
            <value>MANN</value>
            <value>MAT</value>
            <value>MEANS</value>
            <value>MOD</value>
            <value>NA</value>
            <value>NORM</value>
            <value>OPER</value>
            <value>PAR</value>
            <value>PARTL</value>
            <value>PN</value>
            <value>PREC</value>
            <value>PRED</value>
            <value>REAS</value>
            <value>REG</value>
            <value>RESL</value>
            <value>RESTR</value>
            <value>RHEM</value>
            <value>RSTR</value>
            <value>SUBS</value>
            <value>TFHL</value>
            <value>TFRWH</value>
            <value>THL</value>
            <value>THO</value>
            <value>TOWH</value>
            <value>TPAR</value>
            <value>TSIN</value>
            <value>TTILL</value>
            <value>TWHEN</value>
            <value>VOC</value>
            <value>VOCAT</value>
            <value>SENT</value>
        </choice>
    </type>

    <type name="Type.type">
        <choice>
            <value>OBL</value>
            <value>OPT</value>
            <value>TYP</value>
        </choice>
    </type>

</pml_schema>
